package trackers;

import java.io.IOException;
import java.net.*;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Date;
import java.util.List;
import java.util.Random;

import peers.Peer;
import files.TorrentFile;
import trackers.packets.*;

public class TrackerConnection {

	private static final int DEFAULT_NUMWANT = 50;
	private static final int DEFAULT_PORT = 6666;
	private static final int CONNECTION_ID_MAX_AGE = 60000;
	private static final int MAX_TIMEOUT_COUNT = 4;
	
	private final Tracker tracker;
	private final ITrackerSocket socket;
	private final ITransactionIdGenerator transactionIdGenerator;
	
	/**
	 * Randomly generated by this client, used for validation purposes. Should be regenerated for each request
	 */
	private int transactionId;
	
	/**
	 * ID aquired from tracker. Will expire, and should then be renewed
	 */
	private long connection_id;
	
	/*
	 * The system time when the latest connection id was aquired
	 */
	private long timeOfConnectionId;
	
	/**
	 * The number of seconds that should pass between announces
	 */
	private int interval = 0;
	
	private Date intervalElapsed;
	
	/*
	 * The system time of the last announce request made by this connection, in milliseconds
	 */
	private long timeOfLastAnnounce;

	private int timedOutCount = 0;
	
	private boolean isConnected;


	public TrackerConnection(Tracker tracker, ITrackerSocket socket) throws SocketException
	{
		this(tracker, socket, new TransactionIdGenerator());
	}
	
	public TrackerConnection(Tracker tracker, ITrackerSocket socket, ITransactionIdGenerator generator) throws SocketException
	{
		this.tracker = tracker;
		this.socket = socket;
		this.transactionIdGenerator = generator;
		intervalElapsed = new Date();
	}
	
	
	/**
	 * requests peers from the associated tracker. connects first if necessary. this is a convenience method for using both connect() and announce()
	 * @return the peers returned from the tracker, null if announcing failed.
	 * @throws IOException if an IO error occours when attempting to connect to tracker
	 */
	public List<Peer> requestPeers() throws IOException{
		List<Peer> requestPeers = null;
		boolean canConnect = isConnected();
		if(!canConnect){
			canConnect = connect();
		}
		
		if(canConnect && canAnnounce()){
			requestPeers = announce();
		}
		return requestPeers;
	}
	
	/**
	 * Sends a connection request to the tracker.
	 * @return true if the connection attempt succeeded, false if not
	 * @throws IOException
	 */
	public boolean connect() throws IOException
	{
		boolean success = false;
		transactionId = transactionIdGenerator.generate();
		ConnectionRequest cr = new ConnectionRequest(tracker, transactionId);
		//TODO: Exception handling
		socket.send(cr);
		try{
			ITrackerResponse trackerResponse = socket.receive(16);
			if (trackerResponse instanceof ErrorResponse) {
				ErrorResponse error = (ErrorResponse) trackerResponse;
				handleConnectError(error);
			}else{
				ConnectionResponse response = (ConnectionResponse)trackerResponse;
				success = handleConnect(response);
			}
			
		}catch(SocketTimeoutException e){
			System.out.println("connection attempt timed out");
			timedOutCount++;
		}
		return success;
	}

	private void handleConnectError(ErrorResponse error) {
		System.err.println("Connection error: " + error.getMessage());
	}
	
	private boolean handleConnect(ConnectionResponse response){
		boolean success = false;;
		timedOutCount = 0;
		if(response.isValid(transactionId)){
			isConnected = true;
			connection_id = response.getConnection_id();
			success = true;
		}else{
			isConnected = false;
			success = false;
		}
		return success;
	}

	
	/**
	 * Announces to the tracker. Makes the client participate in file sharing on this tracker, for the corresponding torrent, and recieves
	 * a collection of peers in return
	 * @return a list of peers, returned from the tracker.
	 * @throws IOException
	 */
	public List<Peer> announce() throws IOException
	{
		List<Peer> peers = null;
		byte[] peer_id = "78379238472048294759".getBytes();
		AnnounceRequest request = new AnnounceRequest(tracker, this.connection_id, this.transactionId, peer_id, 0, 0, 0, DEFAULT_NUMWANT, (short) socket.getPort());
		socket.send(request);
		try{
			ITrackerResponse trackerResponse = socket.receive(1024);
			if (trackerResponse instanceof ErrorResponse) {
				ErrorResponse error = (ErrorResponse) trackerResponse;
				handleAnnounceError(error);
			}else{
				AnnounceResponse response = (AnnounceResponse)trackerResponse;
				peers = handleAnnounce(response);
			}
			
		}catch(SocketTimeoutException e){
			isConnected = false;
			System.out.println("Connection timed out while announcing. ");
		}
		return peers;
	}
	

	private void handleAnnounceError(ErrorResponse error) {
		System.err.println("Error on announce: " + error.getMessage());
		
	}
	
	private List<Peer> handleAnnounce(AnnounceResponse response) {
		List<Peer> peers = null;
		timeOfLastAnnounce = System.currentTimeMillis();
		
		if(response.isValid(transactionId))
		{
			interval = response.getInterval();
			calculateIntervalElapsed();
			timedOutCount = 0;
			peers = response.getPeers();
		}else{
			isConnected = false;
			System.out.println("Response not valid. Action: " + response.getAction());
		}
		return peers;
		
	}

	private void calculateIntervalElapsed() {
		long time = System.currentTimeMillis() + interval * 1000;
		intervalElapsed = new Date(time);
	}
	
	/**
	 * @return the time for when the time to wait for reannouncing has passed. Returns the current time, if no interval is set.
	 */
	public Date getIntervalElapsed(){
		return intervalElapsed;
	}

	/**
	 * @return the tracker this connection is for
	 */
	public Tracker getTracker() {
		return tracker;
	}

	/**
	 * @return The number of seconds that should pass between connections
	 */
	public int getInterval() {
		return interval;
	}
	
	/**
	 * @return true if connected to tracker, false if not.
	 */
	public boolean isConnected() {
		return isConnected;
	}
	
	public boolean canAnnounce(){
		return System.currentTimeMillis() - timeOfLastAnnounce >= interval * 1000;
	}
	
	public boolean isStale(){
		return timedOutCount >= MAX_TIMEOUT_COUNT;
	}
	
	/**
	 * @return The system time of the last announce request made by this connection, in milliseconds
	 */
	public long getTimeOfLastAnnounce() {
		return timeOfLastAnnounce;
	}

	public interface ITransactionIdGenerator
	{
		int generate();
	}
	
	private static class TransactionIdGenerator implements ITransactionIdGenerator
	{

		@Override
		public int generate() {
			Random random = new Random();
			return random.nextInt();
		}
		
	}
	
	public static class TrackerConnectionComparator implements Comparator<TrackerConnection>{

		@Override
		public int compare(TrackerConnection o1, TrackerConnection o2) {
			return o1.getIntervalElapsed().compareTo(o2.getIntervalElapsed());
		}
		
	}
}
